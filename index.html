<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MÃ©todos de Arreglos en JavaScript</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .method {
            margin-bottom: 40px; /* Aumenta el margen entre mÃ©todos */
        }
        h2 {
            color: #007bff;
        }
        code {
            font-size: 1.1em; /* Aumenta el tamaÃ±o de la fuente */
            background-color: #f4f4f4;
            padding: 5px;
            border-radius: 3px;
            display: inline-block; /* Asegura que el cÃ³digo no se expanda en toda la lÃ­nea */
            white-space: pre-wrap; /* Permite que el cÃ³digo se ajuste dentro del contenedor */
        }
        pre {
            font-size: 1em; /* Aumenta el tamaÃ±o de la fuente para pre */
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 3px;
            padding: 10px;
            overflow-x: auto;
            white-space: pre-wrap; /* Ajusta el texto largo en varias lÃ­neas */
            word-wrap: break-word; /* Evita que las palabras largas se salgan del contenedor */
        }
    </style>
</head>
<body>
    <h1>MÃ©todos de Arreglos en JavaScript</h1>
    
    <div class="method">
        <h2>1. `push()` â•</h2>
        <p><strong>DescripciÃ³n:</strong> Agrega uno o mÃ¡s elementos al final de un arreglo y devuelve la nueva longitud del arreglo.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se llama al mÃ©todo `push()` en el arreglo.</li>
            <li>Se pasan los elementos que se quieren agregar al final del arreglo.</li>
            <li>El mÃ©todo agrega estos elementos al final del arreglo.</li>
            <li>Devuelve la nueva longitud del arreglo.</li>
        </ol>
        <pre><code>let frutas = ['ğŸ', 'ğŸŒ'];
frutas.push('ğŸ‡'); // ['ğŸ', 'ğŸŒ', 'ğŸ‡']</code></pre>
    </div>
    
    <div class="method">
        <h2>2. `pop()` â–</h2>
        <p><strong>DescripciÃ³n:</strong> Elimina el Ãºltimo elemento de un arreglo y lo devuelve.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se llama al mÃ©todo `pop()` en el arreglo.</li>
            <li>El mÃ©todo elimina el Ãºltimo elemento del arreglo.</li>
            <li>Devuelve el elemento eliminado.</li>
            <li>El arreglo se modifica y ahora tiene un elemento menos.</li>
        </ol>
        <pre><code>let frutas = ['ğŸ', 'ğŸŒ', 'ğŸ‡'];
let ultimaFruta = frutas.pop(); // ['ğŸ', 'ğŸŒ']</code></pre>
    </div>
    
    <div class="method">
        <h2>3. `shift()` â¬…ï¸</h2>
        <p><strong>DescripciÃ³n:</strong> Elimina el primer elemento de un arreglo y lo devuelve.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se llama al mÃ©todo `shift()` en el arreglo.</li>
            <li>El mÃ©todo elimina el primer elemento del arreglo.</li>
            <li>Devuelve el elemento eliminado.</li>
            <li>El arreglo se modifica y ahora el primer elemento es el siguiente en la lista.</li>
        </ol>
        <pre><code>let frutas = ['ğŸ', 'ğŸŒ', 'ğŸ‡'];
let primeraFruta = frutas.shift(); // ['ğŸŒ', 'ğŸ‡']</code></pre>
    </div>
    
    <div class="method">
        <h2>4. `unshift()` â¬†ï¸</h2>
        <p><strong>DescripciÃ³n:</strong> Agrega uno o mÃ¡s elementos al principio de un arreglo y devuelve la nueva longitud del arreglo.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se llama al mÃ©todo `unshift()` en el arreglo.</li>
            <li>Se pasan los elementos que se quieren agregar al principio del arreglo.</li>
            <li>El mÃ©todo agrega estos elementos al principio del arreglo.</li>
            <li>Devuelve la nueva longitud del arreglo.</li>
        </ol>
        <pre><code>let frutas = ['ğŸ', 'ğŸŒ'];
frutas.unshift('ğŸ‡'); // ['ğŸ‡', 'ğŸ', 'ğŸŒ']</code></pre>
    </div>
    
    <div class="method">
        <h2>5. `splice()` âœ‚ï¸</h2>
        <p><strong>DescripciÃ³n:</strong> Cambia el contenido de un arreglo eliminando, reemplazando o agregando elementos.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se llama al mÃ©todo `splice()` en el arreglo.</li>
            <li>Se especifica el Ã­ndice a partir del cual se deben realizar los cambios.</li>
            <li>Se especifica el nÃºmero de elementos que se deben eliminar (si se desea).</li>
            <li>Se especifican los elementos a agregar (si se desea).</li>
            <li>El mÃ©todo modifica el arreglo original y devuelve una matriz con los elementos eliminados.</li>
        </ol>
        <pre><code>let frutas = ['ğŸ', 'ğŸŒ', 'ğŸ‡'];
frutas.splice(1, 1, 'ğŸ“', 'ğŸŠ'); // ['ğŸ', 'ğŸ“', 'ğŸŠ', 'ğŸ‡']</code></pre>
    </div>
    
    <div class="method">
        <h2>6. `slice()` ğŸ°</h2>
        <p><strong>DescripciÃ³n:</strong> Devuelve una copia superficial de una porciÃ³n de un arreglo en un nuevo arreglo seleccionado desde el inicio hasta el final (final no incluido) sin modificar el arreglo original.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se llama al mÃ©todo `slice()` en el arreglo.</li>
            <li>Se especifica el Ã­ndice de inicio (inclusive) para la copia.</li>
            <li>Se especifica el Ã­ndice de fin (exclusivo) para la copia.</li>
            <li>Devuelve un nuevo arreglo que contiene los elementos desde el Ã­ndice de inicio hasta el Ã­ndice de fin.</li>
            <li>El arreglo original permanece sin cambios.</li>
        </ol>
        <pre><code>let frutas = ['ğŸ', 'ğŸŒ', 'ğŸ‡'];
let algunasFrutas = frutas.slice(1, 3); // ['ğŸŒ', 'ğŸ‡']</code></pre>
    </div>
    
    <div class="method">
        <h2>7. `forEach()` ğŸ‘€</h2>
        <p><strong>DescripciÃ³n:</strong> Ejecuta una funciÃ³n proporcionada una vez por cada elemento del arreglo.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se llama al mÃ©todo `forEach()` en el arreglo.</li>
            <li>Se pasa una funciÃ³n como argumento.</li>
            <li>El mÃ©todo ejecuta la funciÃ³n para cada elemento del arreglo.</li>
            <li>No modifica el arreglo original y no devuelve un valor.</li>
        </ol>
        <pre><code>let frutas = ['ğŸ', 'ğŸŒ', 'ğŸ‡'];
frutas.forEach(fruta => console.log(fruta)); // Imprime 'ğŸ', 'ğŸŒ', 'ğŸ‡'</code></pre>
    </div>
    
    <div class="method">
        <h2>8. `map()` ğŸ—ºï¸</h2>
        <p><strong>DescripciÃ³n:</strong> Crea un nuevo arreglo con los resultados de la llamada a una funciÃ³n proporcionada en cada elemento del arreglo.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se llama al mÃ©todo `map()` en el arreglo.</li>
            <li>Se pasa una funciÃ³n como argumento.</li>
            <li>El mÃ©todo ejecuta la funciÃ³n para cada elemento del arreglo.</li>
            <li>Devuelve un nuevo arreglo con los resultados de la funciÃ³n.</li>
            <li>El arreglo original permanece sin cambios.</li>
        </ol>
        <pre><code>let numeros = [1, 2, 3];
let dobles = numeros.map(num => num * 2); // [2, 4, 6]</code></pre>
    </div>
    
    <div class="method">
        <h2>9. `filter()` ğŸš¦</h2>
        <p><strong>DescripciÃ³n:</strong> Crea un nuevo arreglo con todos los elementos que pasen la prueba implementada por la funciÃ³n proporcionada.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se llama al mÃ©todo `filter()` en el arreglo.</li>
            <li>Se pasa una funciÃ³n como argumento.</li>
            <li>El mÃ©todo ejecuta la funciÃ³n para cada elemento del arreglo.</li>
            <li>Devuelve un nuevo arreglo con los elementos que pasaron la prueba.</li>
            <li>El arreglo original permanece sin cambios.</li>
        </ol>
        <pre><code>let numeros = [1, 2, 3, 4, 5];
let pares = numeros.filter(num => num % 2 === 0); // [2, 4]</code></pre>
    </div>
    
    <div class="method">
        <h2>10. `find()` ğŸ”</h2>
        <p><strong>DescripciÃ³n:</strong> Devuelve el primer elemento del arreglo que cumple con la funciÃ³n de prueba proporcionada.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se llama al mÃ©todo `find()` en el arreglo.</li>
            <li>Se pasa una funciÃ³n como argumento.</li>
            <li>El mÃ©todo ejecuta la funciÃ³n para cada elemento del arreglo hasta que encuentra uno que pase la prueba.</li>
            <li>Devuelve el primer elemento que pasa la prueba.</li>
            <li>Si ningÃºn elemento pasa la prueba, devuelve <code>undefined</code>.</li>
        </ol>
        <pre><code>let numeros = [1, 2, 3, 4, 5];
let mayorQueTres = numeros.find(num => num > 3); // 4</code></pre>
    </div>
    
    <div class="method">
        <h2>11. `findIndex()` ğŸ§­</h2>
        <p><strong>DescripciÃ³n:</strong> Devuelve el Ã­ndice del primer elemento del arreglo que cumple con la funciÃ³n de prueba proporcionada.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se llama al mÃ©todo `findIndex()` en el arreglo.</li>
            <li>Se pasa una funciÃ³n como argumento.</li>
            <li>El mÃ©todo ejecuta la funciÃ³n para cada elemento del arreglo hasta encontrar uno que pase la prueba.</li>
            <li>Devuelve el Ã­ndice del primer elemento que pasa la prueba.</li>
            <li>Si ningÃºn elemento pasa la prueba, devuelve <code>-1</code>.</li>
        </ol>
        <pre><code>let numeros = [1, 2, 3, 4, 5];
let indiceMayorQueTres = numeros.findIndex(num => num > 3); // 3</code></pre>
    </div>
    
    <div class="method">
        <h2>12. `some()` ğŸ¤”</h2>
        <p><strong>DescripciÃ³n:</strong> Prueba si al menos un elemento del arreglo cumple con la funciÃ³n de prueba proporcionada. Devuelve <code>true</code> si al menos uno cumple, y <code>false</code> si ninguno cumple.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se llama al mÃ©todo `some()` en el arreglo.</li>
            <li>Se pasa una funciÃ³n como argumento.</li>
            <li>El mÃ©todo ejecuta la funciÃ³n para cada elemento del arreglo.</li>
            <li>Si encuentra un elemento que pasa la prueba, devuelve <code>true</code> inmediatamente.</li>
            <li>Si ningÃºn elemento pasa la prueba, devuelve <code>false</code>.</li>
        </ol>
        <pre><code>let numeros = [1, 2, 3, 4, 5];
let hayMayoresDeTres = numeros.some(num => num > 3); // true</code></pre>
    </div>
    
    <div class="method">
        <h2>13. `every()` âœ…</h2>
        <p><strong>DescripciÃ³n:</strong> Prueba si todos los elementos del arreglo cumplen con la funciÃ³n de prueba proporcionada. Devuelve <code>true</code> si todos cumplen, y <code>false</code> si al menos uno no cumple.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se llama al mÃ©todo `every()` en el arreglo.</li>
            <li>Se pasa una funciÃ³n como argumento.</li>
            <li>El mÃ©todo ejecuta la funciÃ³n para cada elemento del arreglo.</li>
            <li>Si todos los elementos pasan la prueba, devuelve <code>true</code>.</li>
            <li>Si al menos un elemento no pasa la prueba, devuelve <code>false</code>.</li>
        </ol>
        <pre><code>let numeros = [2, 4, 6];
let todosPares = numeros.every(num => num % 2 === 0); // true</code></pre>
    </div>
    
    <div class="method">
        <h2>14. `reduce()` â•â¡ï¸</h2>
        <p><strong>DescripciÃ³n:</strong> Ejecuta una funciÃ³n reductora sobre cada elemento del arreglo, resultando en un Ãºnico valor.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se llama al mÃ©todo `reduce()` en el arreglo.</li>
            <li>Se pasa una funciÃ³n reductora y un valor inicial como argumentos.</li>
            <li>La funciÃ³n reductora se ejecuta para cada elemento del arreglo, acumulando un valor.</li>
            <li>Devuelve el valor acumulado final.</li>
            <li>El arreglo original permanece sin cambios.</li>
        </ol>
        <pre><code>let numeros = [1, 2, 3, 4];
let suma = numeros.reduce((acc, num) => acc + num, 0); // 10</code></pre>
    </div>
    
    <div class="method">
        <h2>15. `sort()` ğŸ”€</h2>
        <p><strong>DescripciÃ³n:</strong> Ordena los elementos del arreglo en su lugar y devuelve el arreglo ordenado.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se llama al mÃ©todo `sort()` en el arreglo.</li>
            <li>Opcionalmente, se pasa una funciÃ³n de comparaciÃ³n como argumento.</li>
            <li>El mÃ©todo ordena los elementos del arreglo segÃºn la funciÃ³n de comparaciÃ³n.</li>
            <li>Si no se proporciona una funciÃ³n de comparaciÃ³n, los elementos se ordenan como cadenas de texto por defecto.</li>
            <li>Devuelve el arreglo ordenado.</li>
            <li>El arreglo original se modifica.</li>
        </ol>
        <pre><code>let frutas = ['ğŸ', 'ğŸŒ', 'ğŸ‡'];
frutas.sort(); // ['ğŸŒ', 'ğŸ', 'ğŸ‡']</code></pre>
    </div>
    
    <div class="method">
        <h2>16. `reverse()` ğŸ”„</h2>
        <p><strong>DescripciÃ³n:</strong> Invierte el orden de los elementos del arreglo en su lugar.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se llama al mÃ©todo `reverse()` en el arreglo.</li>
            <li>El mÃ©todo invierte el orden de los elementos del arreglo.</li>
            <li>Devuelve el arreglo invertido.</li>
            <li>El arreglo original se modifica.</li>
        </ol>
        <pre><code>let frutas = ['ğŸ', 'ğŸŒ', 'ğŸ‡'];
frutas.reverse(); // ['ğŸ‡', 'ğŸŒ', 'ğŸ']</code></pre>
    </div>
    
    <div class="method">
        <h2>17. `findIndex()` ğŸ§­</h2>
        <p><strong>DescripciÃ³n:</strong> Devuelve el Ã­ndice del primer elemento que cumple con la funciÃ³n de prueba proporcionada.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se llama al mÃ©todo `findIndex()` en el arreglo.</li>
            <li>Se pasa una funciÃ³n como argumento.</li>
            <li>El mÃ©todo ejecuta la funciÃ³n para cada elemento del arreglo hasta encontrar uno que pase la prueba.</li>
            <li>Devuelve el Ã­ndice del primer elemento que pasa la prueba.</li>
            <li>Si ningÃºn elemento pasa la prueba, devuelve <code>-1</code>.</li>
        </ol>
        <pre><code>let numeros = [1, 2, 3, 4, 5];
let indiceMayorQueTres = numeros.findIndex(num => num > 3); // 3</code></pre>
    </div>

    <div class="method">
        <h2>18. `Destructuring` ğŸ§©</h2>
        <p><strong>DescripciÃ³n:</strong> Permite extraer valores de arreglos o propiedades de objetos en variables distintas.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se usa una sintaxis especial para extraer valores de un arreglo u objeto.</li>
            <li>Para arreglos, se colocan corchetes alrededor de las variables a asignar.</li>
            <li>Para objetos, se colocan llaves alrededor de las variables a asignar.</li>
            <li>Los valores se asignan en el orden de los elementos del arreglo o las propiedades del objeto.</li>
        </ol>
        <pre><code>let frutas = ['ğŸ', 'ğŸŒ', 'ğŸ‡'];
let [manzana, platano, uva] = frutas; // manzana = 'ğŸ', platano = 'ğŸŒ', uva = 'ğŸ‡'</code></pre>
    </div>

    <div class="method">
        <h2>19. Operador Rest (...) ğŸ“¦</h2>
        <p><strong>DescripciÃ³n:</strong> Permite representar un nÃºmero indefinido de argumentos como un arreglo.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se usa el operador <code>...</code> antes de una variable en una funciÃ³n o declaraciÃ³n de arreglo.</li>
            <li>En una funciÃ³n, captura todos los argumentos restantes en un solo arreglo.</li>
            <li>En una declaraciÃ³n de arreglo, captura todos los elementos restantes en un solo arreglo.</li>
        </ol>
        <pre><code>function sumar(...numeros) {
    return numeros.reduce((acc, num) => acc + num, 0);
}
sumar(1, 2, 3, 4); // 10</code></pre>
    </div>

    <div class="method">
        <h2>20. Operador Spread (...) ğŸŒŒ</h2>
        <p><strong>DescripciÃ³n:</strong> Permite expandir elementos de un arreglo u objeto en lugares donde se esperan mÃºltiples elementos.</p>
        <p><strong>Pasos:</strong></p>
        <ol>
            <li>Se usa el operador <code>...</code> antes de un arreglo u objeto.</li>
            <li>En un arreglo, expande los elementos individuales en un nuevo contexto.</li>
            <li>En un objeto, expande las propiedades individuales en un nuevo contexto.</li>
        </ol>
        <pre><code>let frutas = ['ğŸ', 'ğŸŒ', 'ğŸ‡'];
let otrasFrutas = ['ğŸ“', ...frutas, 'ğŸŠ']; // ['ğŸ“', 'ğŸ', 'ğŸŒ', 'ğŸ‡', 'ğŸŠ']</code></pre>
    </div>
</body>
</html>
